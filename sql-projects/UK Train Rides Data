-- Dataset: UK Train Rides from Maven Analytics
-- Source: https://www.kaggle.com/datasets/helddata/uk-train-rides-maven-rail-challenge
-- Queried using: MySQL Workbench

SELECT * FROM ride_data; -- QA only

/*
Creating a view called 'RIDE_DATA_VIEW' that captures all the columns from 
the 'RIDE_DATA' table along with adding additional columns for the purpose of
easily querying frequent routes, trip duration and time analysis.
 
 Columns added:
    `date_of_arrival`: 
        Created to match `date_of_journey` column as one didn't previously exist
        and to create arrival column timestamps.
                        
	`departure_ts`, 
    `arrival_ts`, 
    `actual_arrival_ts`:
        (ts = timestamp) 
        Combines time columns `arrival_time`, `actual_arrival_time` and `departure_time` 
        columns with date columns `date_of_journey` and `date_of_arrival` and converts 
        into timestamp columns.
                        
    `route`: 
        Combines `departure_station` and `arrival_station`. Used for frequent route analysis.
    `purchase_time_range`: 
        Uses `time_of_purchase` column to categorize times into time slots
*/
CREATE VIEW ride_data_view AS
SELECT 
    *,
    TIMESTAMP(date_of_journey, departure_time) AS departure_ts,
    TIMESTAMP(date_of_arrival, arrival_time) AS arrival_ts,
    TIMESTAMP(date_of_arrival, actual_arrival_time) AS actual_arrival_ts,
    CASE
		WHEN TIME(time_of_purchase) BETWEEN '00:00:00' AND '04:00:00' THEN '12AM_4AM'
		WHEN TIME(time_of_purchase) BETWEEN '04:00:00' AND '08:00:00' THEN '4AM_8AM'
		WHEN TIME(time_of_purchase) BETWEEN '08:00:00' AND '12:00:00' THEN '8AM_12AM'
		WHEN TIME(time_of_purchase) BETWEEN '12:00:00' AND '16:00:00' THEN '12PM_4PM'
		WHEN TIME(time_of_purchase) BETWEEN '16:00:00' AND '20:00:00' THEN '4PM_8PM'
		WHEN TIME(time_of_purchase) BETWEEN '20:00:00' AND '24:00:00' THEN '8PM_12AM'
		ELSE 'error'
	END AS purchase_time_range
FROM
    (SELECT 
        *,
        CONCAT(departure_station, '_', arrival_destination) AS route,
        CASE
            WHEN actual_arrival_time < departure_time THEN DATE_ADD(date_of_journey, INTERVAL 1 DAY)
            ELSE date_of_journey
        END AS date_of_arrival
    FROM 
		ride_data
    ) AS added_date_of_arrival;

SELECT * FROM ride_data_view; -- QA only

/*
Analysis
*/
--  Finding total tickets sold by year and month
SELECT 
    YEAR(date_of_purchase) AS yr,
    MONTH(date_of_purchase) AS mnth,
    COUNT(transaction_id) AS total_purchased,
    SUM(price) AS total_revenue
FROM 
	ride_data_view
GROUP BY 
	yr, 
    mnth;

-- Comparing online sales vs in-person station sales
SELECT 
    purchase_type,
    COUNT(transaction_id) AS tickets_sold,
    SUM(price) AS total_revenue
FROM 
	ride_data_view
GROUP BY 
	purchase_type;

-- Identifying the top 10 most popular routes
SELECT
	*
FROM  (
	SELECT 
		DENSE_RANK() OVER (ORDER BY COUNT(transaction_id) DESC) AS popularity,
		route,
		COUNT(transaction_id) AS total_sold
	FROM
		ride_data_view
	GROUP BY 
		route
) ranking
WHERE 
	popularity <= 10;

-- Calculating average ticket prices per route
SELECT 
    route,
    ROUND(AVG(price), 2) as average_price
FROM
    ride_data_view
GROUP BY 
	route
ORDER BY 
	average_price DESC;
    
-- Determining the distribution of payment methods
SELECT 
    SUM(payment_method = 'Contactless') * 100 / COUNT(*) AS contactless_pct,
    SUM(payment_method = 'Credit Card') * 100 / COUNT(*) AS credit_card_pct,
    SUM(payment_method = 'Debit Card') * 100 / COUNT(*) AS debit_card_pct
FROM
    ride_data_view;
    
-- Calculating total revenue generated by each payment method
SELECT 
    payment_method, 
    SUM(price) AS total_revenue
FROM
    ride_data_view
GROUP BY 
    payment_method;

-- Analyzing the percentage of ticket sales attributed to each type of Railcard (Adult, Senior, Disabled).
SELECT 
    SUM(railcard = 'None') * 100 / COUNT(*) AS no_railcard_pct,
    SUM(railcard = 'Adult') * 100 / COUNT(*) AS adult_pct,
    SUM(railcard = 'Senior') * 100 / COUNT(*) AS senior_pct,
    SUM(railcard = 'Disabled') * 100 / COUNT(*) AS disabled_pct
FROM
    ride_data_view;

-- Comparing the average ticket price for Railcard holders vs. non-Railcard holders.
SELECT 
    ROUND(
        AVG(
            CASE WHEN railcard IN ('Adult' , 'Senior', 'Disabled') THEN price END
            )
        ,2) AS avg_price_railcard,
    ROUND(
        AVG(
            CASE WHEN railcard = 'None' THEN price END
            )
        ,2) AS avg_price_non_railcard
FROM
    ride_data_view;

-- Comparing the number of Standard vs. First Class tickets sold and their average price
SELECT 
    ticket_class,
    COUNT(*) AS tickets_sold,
    ROUND(AVG(price), 2) AS avg_price
FROM
    ride_data_view
GROUP BY 
    ticket_class;

-- Analyzing the likelihood of ticket types being on time, delayed or cancelled
SELECT 
    ticket_type,
    COUNT(CASE WHEN journey_status = 'On Time' THEN transaction_id END) * 100.0
		/ COUNT(*) on_time,
    COUNT(CASE WHEN journey_status = 'Delayed' THEN transaction_id END) * 100.0 
		/ COUNT(*) AS delay,
    COUNT(CASE WHEN journey_status = 'Cancelled' THEN transaction_id END) * 100.0
		/ COUNT(*) AS cancelled
FROM
    ride_data_view
GROUP BY 
    ticket_type;

-- Calculating average travel times for each route
SELECT 
    route,
    TIME_FORMAT( -- re-formats to timestamp
		SEC_TO_TIME( -- converts averaged seconds back to time value
			AVG( -- get the averages of seconds
				TIME_TO_SEC( -- converts to seconds
					TIMEDIFF( -- returns travel duration as a timestamp
						actual_arrival_ts, departure_ts
                    )
				)
			)
		),
	'%H:%i:%s') AS avg_travel_time
FROM
    ride_data_view
GROUP BY 
    route
ORDER BY 
    avg_travel_time DESC;

-- Comparing cancelled vs delayed routes
SELECT 
    route,
    SUM(journey_status = 'Cancelled') AS total_cancelled,
    SUM(journey_status = 'Delayed') AS total_delayed
FROM
    ride_data_view
GROUP BY 
    route
ORDER BY 
    total_cancelled DESC, 
    total_delayed DESC;

-- Comparing scheduled vs. actual arrival times to identify routes with frequent delays
SELECT 
    route,
    SUM(journey_status = 'Delayed') * 100 / COUNT(journey_status) AS percent_delayed,
    SUM(journey_status = 'On Time') * 100 / COUNT(journey_status) AS percent_ontime,
    SUM(journey_status = 'Cancelled') * 100 / COUNT(journey_status) AS percent_cancelled
FROM
    ride_data_view
GROUP BY 
    route
ORDER BY 
    percent_delayed DESC;

-- Identifying the most common reasons for delays and their average delay times
SELECT 
    reason_for_delay,
    COUNT(*) AS frequency,
    TIME_FORMAT(
		SEC_TO_TIME(
			AVG(TIME_TO_SEC(TIMEDIFF(actual_arrival_ts, arrival_ts)))
		),
	'%H:%i:%s') AS average_delay_time
FROM
    ride_data_view
WHERE 
    journey_status = 'Delayed'
GROUP BY 
    reason_for_delay
ORDER BY 
    frequency DESC;

-- Calculating the percentage of delayed or canceled journeys that resulted in a refund request
SELECT 
    SUM(journey_status = 'Cancelled') * 100 / COUNT(*) AS cancelled_trips_refunded,
    SUM(journey_status = 'Delayed') * 100 / COUNT(*) AS delayed_trips_refunded
FROM
    ride_data_view
WHERE 
    refund_request = 'Yes';

-- Analyzing the reasons for delays that most often lead to refund requests
SELECT 
    reason_for_delay, 
    COUNT(*) AS refund_requests
FROM
    ride_data_view
WHERE
    journey_status = 'Delayed'
	AND refund_request = 'Yes'
GROUP BY 
    reason_for_delay
ORDER BY 
    refund_requests DESC;

-- Determining peak times for ticket purchases
SELECT 
    purchase_time_range,
    COUNT(*) AS total_purchases
FROM
    ride_data_view
GROUP BY 
    purchase_time_range
ORDER BY 
    total_purchases DESC;

-- Pulling the most purchased route for every time slot
WITH time_rankings AS (
	SELECT
		-- DENSE_RANK to add rankings based on route popularity per time range
		DENSE_RANK() OVER (PARTITION BY purchase_time_range ORDER BY tickets_sold DESC) AS ranking,
        purchase_time_range,
        route,
        tickets_sold
    FROM ( -- Using previously created time ranges to query with routes and tickets_sold
        SELECT 
            purchase_time_range,
            route,
            COUNT(*) AS tickets_sold
        FROM
            ride_data_view
        GROUP BY 
            purchase_time_range, route
    ) AS hourly_purchases
)
SELECT
    purchase_time_range,
    route,
    tickets_sold
FROM time_rankings
WHERE 
    ranking = 1 -- Filtering to pull the most purchased route
ORDER BY 
    tickets_sold desc;

-- Comparing online vs. station purchases by time of day
SELECT 
   purchase_time_range,
    SUM(purchase_type = 'Online') AS online_puchases,
    SUM(purchase_type = 'Station') AS station_purchases
FROM
    ride_data_view
GROUP BY 
    purchase_time_range;

-- Comparing the sales volume for discounted tickets (Railcard, Advance, Off-Peak) vs. full-price tickets.
SELECT 
    CASE 
		WHEN ticket_type IN ('Advance' , 'Off-Peak') AND railcard != 'None' THEN 'discounted_tickets'
        ELSE 'full_price'
    END AS ticket_types,
    COUNT(*) as tickets_sold
FROM
    ride_data_view
GROUP BY 
    ticket_types;
